/**
 * Feature Flags for Architect AI Platform
 *
 * Controls experimental and progressive features
 */

export const FEATURE_FLAGS = {
  /**
   * Geometry-First Generation Pipeline
   *
   * When enabled (default):
   * - Uses spatial layout algorithm for exact dimensions
   * - Generates 2D technical views from geometry (not AI)
   * - 3D photorealistic views use geometry-enforced prompts
   * - Target consistency: 99.5%+
   *
   * When disabled:
   * - Falls back to legacy DNA-only AI generation
   * - All 13 views generated by FLUX.1 AI
   * - Current consistency: 98%
   *
   * Implementation: Progressive 8-milestone rollout
   * Rollback: Set to false to revert to legacy pipeline
   *
   * @type {boolean}
   * @default true
   */
  geometryFirst: true,

  /**
   * Show geometry data preview in UI
   *
   * Displays spatial layout and room dimensions
   * before final generation. Useful for validation.
   *
   * @type {boolean}
   * @default false
   */
  showGeometryPreview: false,

  /**
   * Cache geometry calculations
   *
   * Stores geometry pipeline results in sessionStorage
   * for faster regeneration on same site polygon.
   *
   * @type {boolean}
   * @default true
   */
  cacheGeometry: true,

  /**
   * Parallel generation mode
   *
   * Generate 2D views from geometry (fast, local)
   * and 3D views from FLUX AI (slow, API) in parallel.
   * Reduces total generation time from ~3min to ~2min.
   *
   * @type {boolean}
   * @default true
   */
  parallelGeneration: true,

  /**
   * Enhanced consistency validation
   *
   * Enable geometry-based consistency checks:
   * - Floor plan area vs geometry footprint
   * - Elevation heights vs geometry floors
   * - Window counts vs openings generator
   *
   * @type {boolean}
   * @default true
   */
  enhancedConsistencyChecks: true,

  /**
   * Debug mode for geometry pipeline
   *
   * Logs detailed geometry calculations to console
   * and displays intermediate steps in UI.
   *
   * @type {boolean}
   * @default false
   */
  debugGeometry: false
};

/**
 * Check if a feature is enabled
 */
export function isFeatureEnabled(flagName) {
  if (!(flagName in FEATURE_FLAGS)) {
    console.warn(\`[WARNING] Unknown feature flag: \${flagName}\`);
    return false;
  }
  return FEATURE_FLAGS[flagName] === true;
}

/**
 * Set a feature flag value (for testing/admin)
 */
export function setFeatureFlag(flagName, value) {
  if (!(flagName in FEATURE_FLAGS)) {
    console.warn(\`[WARNING] Unknown feature flag: \${flagName}\`);
    return;
  }

  const oldValue = FEATURE_FLAGS[flagName];
  FEATURE_FLAGS[flagName] = value;

  console.log(\`[FLAG] Feature flag updated: \${flagName}\`, {
    from: oldValue,
    to: value
  });

  // Persist to sessionStorage for current session
  try {
    const flags = JSON.parse(sessionStorage.getItem('featureFlags') || '{}');
    flags[flagName] = value;
    sessionStorage.setItem('featureFlags', JSON.stringify(flags));
  } catch (error) {
    console.error('Failed to persist feature flag:', error);
  }
}

/**
 * Get all feature flags and their current values
 */
export function getAllFeatureFlags() {
  return { ...FEATURE_FLAGS };
}

/**
 * Reset all feature flags to defaults
 */
export function resetFeatureFlags() {
  try {
    sessionStorage.removeItem('featureFlags');
  } catch (error) {
    console.error('Failed to clear feature flags:', error);
  }

  FEATURE_FLAGS.geometryFirst = true;
  FEATURE_FLAGS.showGeometryPreview = false;
  FEATURE_FLAGS.cacheGeometry = true;
  FEATURE_FLAGS.parallelGeneration = true;
  FEATURE_FLAGS.enhancedConsistencyChecks = true;
  FEATURE_FLAGS.debugGeometry = false;

  console.log('[RESET] Feature flags reset to defaults');
}

/**
 * Load feature flags from sessionStorage (if overridden)
 */
export function loadFeatureFlagsFromStorage() {
  try {
    const stored = sessionStorage.getItem('featureFlags');
    if (stored) {
      const flags = JSON.parse(stored);
      Object.keys(flags).forEach(key => {
        if (key in FEATURE_FLAGS) {
          FEATURE_FLAGS[key] = flags[key];
        }
      });
      console.log('[LOADED] Feature flags loaded from storage:', flags);
    }
  } catch (error) {
    console.error('Failed to load feature flags:', error);
  }
}

// Auto-load on module import
loadFeatureFlagsFromStorage();

/**
 * Development helper: Log current feature flag status
 */
export function logFeatureFlags() {
  console.group('[FLAGS] Feature Flags Status');
  Object.entries(FEATURE_FLAGS).forEach(([key, value]) => {
    const icon = value ? '[ON]' : '[OFF]';
    console.log(\`\${icon} \${key}: \${value}\`);
  });
  console.groupEnd();
}

// Log feature flags in development mode
if (process.env.NODE_ENV === 'development') {
  console.log('[FLAGS] Feature Flags initialized');
  console.log('   geometryFirst:', FEATURE_FLAGS.geometryFirst);
  console.log('   Use setFeatureFlag() to override');
}

export default FEATURE_FLAGS;

// CommonJS compatibility for Node.js testing
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    FEATURE_FLAGS,
    isFeatureEnabled,
    setFeatureFlag,
    getAllFeatureFlags,
    resetFeatureFlags,
    loadFeatureFlagsFromStorage,
    logFeatureFlags
  };
}
